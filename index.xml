<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Showcase Template</title><link>https://vcwork.github.io/project/</link><description>Recent content in Introduction on Showcase Template</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://vcwork.github.io/project/index.xml" rel="self" type="application/rss+xml"/><item><title>(1) 3D Brush</title><link>https://vcwork.github.io/project/docs/Entrega2/3Dbrush/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://vcwork.github.io/project/docs/Entrega2/3Dbrush/</guid><description>Entrega 2 - 3D Brush # Introducción # Se presentará un demo que ilustra una aplicación de pintura en 3D que utiliza transformaciones de pantalla a mundo, similares a las empleadas en el Ray-casting, en la cual el usuario será capaz de mover con los dedos de su mano izquierda el mundo y con los dedos de su mano derecha será capaz de dibujar, todo esto a través de la cámara donde los rayos de luz virtuales se &amp;ldquo;emiten&amp;rdquo; o &amp;ldquo;trazan&amp;rdquo; en su camino desde el punto focal de una cámara a través de cada píxel en el sensor de la cámara para determinar qué es visible a lo largo del rayo en el escena 3D.</description></item><item><title>(1) Óscar Alejandro Gómez</title><link>https://vcwork.github.io/project/docs/Entrega3/ShaderExer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://vcwork.github.io/project/docs/Entrega3/ShaderExer/</guid><description>Entrega Entrega 3 - Shaders # Coloring # Agregar el color azul a la textura # Ver Código let colorShader; let cmy; let v1, v2, v3; let colorr = 255; function preload() { // The vertex shader defines how vertices are projected onto clip space. // Most of the times a projection and modelview matrix are needed for this // (see: https://visualcomputing.github.io/docs/shaders/programming_paradigm/). // Here, however, we are going to: // 1.</description></item><item><title>(2) Gerson Nicolás Pineda</title><link>https://vcwork.github.io/project/docs/Entrega3/gerson_codes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://vcwork.github.io/project/docs/Entrega3/gerson_codes/</guid><description> Entrega 3 - Shaders # Renderización por rasterización # Aplicaciones #</description></item><item><title>(2) Ray Tracing</title><link>https://vcwork.github.io/project/docs/Entrega2/Ray-Tracing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://vcwork.github.io/project/docs/Entrega2/Ray-Tracing/</guid><description>Entrega 2 - Ray Tracing # Ray tracing # Introducción # El ray tracing es una de las dos soluciones más populares dadas para el renderizado de objetos de tres dimensiones en pantallas de sólo dos. Esta técnica permite la creación de imágenes que se asemejan a la realidad de una forma relativamente sencilla. A continuación se muestra la historia de la técnica, la teoría que se encuentra detrás y una aplicación que permite visualizar a rasgos generales como es el funcionamiento del ray tracing, es decir la realización de una prueba de concepto.</description></item><item><title>(3) Fernando Moreno Bautista</title><link>https://vcwork.github.io/project/docs/Entrega3/Fernando/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://vcwork.github.io/project/docs/Entrega3/Fernando/</guid><description>Entrega Entrega 3 - Shaders # Introducción # A lo largo de la siguiente página se podrá observar una serie de ejercicios en los cuales se aplican los shaders, esto en los siguientes aspectos: Coloring, Texturing, Image Processing y Procedural Texturing, ejercicios en los cuales se podrán ver los diferentes usos de estos shaders los cuales se hacen mediante hardware y al final veremos un pequeño análisis entre las diferencias que existen entre los ejercicios de la primera entrega, los cuales fueron mediante software y por ultimo una conclusión.</description></item><item><title>(3) Renderización en software</title><link>https://vcwork.github.io/project/docs/Entrega2/rendering/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://vcwork.github.io/project/docs/Entrega2/rendering/</guid><description>Entrega 2 - Renderización en software # Renderizado por software # Se refiere a cuando el proceso de renderizado es realizado sin involucrar unidades de procesamiento gráfico –GPUs–, es decir, usando únicamente CPUs. Este tipo de renderizado tiene la ventaja de no depender del rendimiento y memoria de la GPU, además de no tener que pagar por otro dispositivo. Sin embargo, estas ventajas frecuentemente suelen verse opacadas por las ventajas que ofrece el renderizado en GPU, como que este último es significativamente más rápido debido a que las GPUs están optimizadas para el procesamiento gráfico y la computación paralela.</description></item><item><title>(4) Comparación frame rate, Oscar Gómez 2</title><link>https://vcwork.github.io/project/docs/Entrega3/comparacion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://vcwork.github.io/project/docs/Entrega3/comparacion/</guid><description>Comparacón en el frameRate entre renderización por software y pr hardware # Esferas hechas por software # Ver Código let canvas; let canvas_context; let canvas_pitch; let canvas_buffer; let viewport_size ; let projection_plane_z; let camera_position; let background_color; let spheres; let lights; let dy; let incre ; let dx; let increx ; let liSliderPInt; let liSliderPX; let liSliderPY; function setup(){ canvas = createCanvas(600,600); //console.log(drawingContext); canvas_buffer = drawingContext.getImageData(0,0,canvas.width, canvas.height); canvas_pitch = canvas.width*4; viewport_size = 1; projection_plane_z = 1; camera_position = [0, 0, 0]; background_color = [255, 255, 255]; dy = 0.</description></item><item><title>Entrega 1</title><link>https://vcwork.github.io/project/docs/ilusiones/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://vcwork.github.io/project/docs/ilusiones/</guid><description>Entrega 1 - Ilusiones ópticas # Introducción # Se presentará el efecto estroboscópico en el cual se parte de imágenes que se presentan de forma continua generando lo que parece ser un movimiento fluido, esto debido al efecto Phi, dentro de los posibles consecuencias que este efecto puede llegar a tener se encuentra una que relaciona el movimiento y la percepción de los colores en las pantallas de los computadores.</description></item><item><title>Parte I</title><link>https://vcwork.github.io/project/docs/Entrega3/parte1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://vcwork.github.io/project/docs/Entrega3/parte1/</guid><description>Entrega 3 - Parte I # Introducción # En este reporte se podrán observar los resultados obtenidos al desarrollar los ejercicios propuestos, todos mediante la aplicación de los conceptos relacionados con los shaders. Primero, se observarán los resultados de la implementación de múltiples herramientas de coloreado de luminosidad, para posteriormente ver los resultados de implementar teñido de textura (texture tinting).
Luego, se explorarán los resultados de implementar enmascarado de imágenes/video y otras herramientas de visualización, junto con las herramientas de coloreado de luminosidad.</description></item><item><title>Parte II</title><link>https://vcwork.github.io/project/docs/Entrega3/parte2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://vcwork.github.io/project/docs/Entrega3/parte2/</guid><description> Entrega 3 - Parte II #</description></item><item><title>Parte III</title><link>https://vcwork.github.io/project/docs/Entrega3/parte3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://vcwork.github.io/project/docs/Entrega3/parte3/</guid><description>Entrega 3 - Parte III # WebGL Lighting y Material # Lighting # La idea de la ecuación de iluminación es calcular el color de un punto en una superficie. Como parámetros recibe las propiedades del material de la superficie y las propiedades de la fuente de luz que ilumina la superficie. Así mismo, el ángulo en que incide la luz también resulta importante, pero este puede ser calculado a partir de la dirección en la que está la fuente de luz y del vector normal de la superficie.</description></item></channel></rss>